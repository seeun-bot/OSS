## 버전관리 개요


## 📌 버전 관리의 필요성
파일을 작업하다 보면 **과거 어느 시점의 상태로 되돌리고 싶은 순간**이 존재한다.

과거 방식:
- 파일 이름을 계속 바꿔서 저장  
  → 예: 최종진짜_final_수정본2(진짜진짜).docx  
- 폴더를 복사해서 버전별로 보관  
  → 파일이 많아질수록 혼란 + 비효율

📍 버전 관리는 이러한 문제를 해결하기 위해  
➡ **변경 이력 전체를 체계적으로 기록 & 추적**하는 기능 제공

---

## 📌 버전 관리란?
시간이 흐르며 **파일이 어떻게 달라졌는지를 기록하는 시스템**

할 수 있는 것:
- 누가, 언제, 어디를, 어떻게 수정했는지 확인 가능
- 필요한 경우 특정 시점으로 **시간여행(rollback)**
- 여러 사용자가 동시에 작업할 때 **충돌 해결의 기반 제공**

---

## 📌 버전 관리 도구 사용 방식
| 방식 | 설명 |
|------|------|
| CLI (Command Line Interface) | Git Bash 같은 텍스트 기반 명령 입력 |
| GUI (Graphical UI) | 소스트리 등 그래픽 화면으로 직관적 사용 |

CLI는 전문가 느낌 팍!,  
GUI는 마음 편하게 클릭-click ☕  
→ 둘 다 장점이 있으므로 병행 사용 추천!

---

## 📌 커밋(commit) 개념
커밋이란:
- 현재 프로젝트 상태를 저장하는 **스냅샷**
- 변경 이력을 저장소에 기록하는 행위
- 커밋들이 순서대로 쌓이며 **버전 히스토리** 생성

특징:
- 가장 최근 커밋을 가리키는 포인터 = **HEAD**

> 쉽게 말하면  
> “현재 프로젝트가 찍혀 있는 사진이 HEAD가 보고 있는 사진!”

---

## 📌 지역 저장소와 원격 저장소
| 구분 | 설명 |
|------|------|
| 지역(Local) 저장소 | 내 컴퓨터 안에 존재 |
| 원격(Remote) 저장소 | GitHub 같은 서버 기반 저장소 |

---

### 🔧 관련 명령어 요약
| 명령어 | 설명 |
|--------|------|
| `clone` | 원격 저장소 복제 |
| `add` | 변경사항 스테이징 |
| `commit` | 스냅샷 저장 |
| `push` | 지역 → 원격 저장 |
| `pull` | 원격 → 지역 가져오기 |

# 깃과 깃허브 개요 정리

---

## 🧬 Git의 탄생과 특징
- Git은 **2005년 리누스 토르발스가 개발한 분산 버전 관리 시스템**
- 모든 개발자는 자신의 PC에 전체 소스 코드 복사본 보유
- 빠르고 안정적인 버전 관리 가능

---

## 🧩 Git의 주요 기능
- **파일 변경을 시간순으로 추적**
- 여러 개발자가 **독립적으로 작업 후 merge 가능**
- **브랜치 기반 비선형 개발** → 여러 버전 동시 진행 🌱🌳

---

## 🧱 Git의 내부 구조
| 영역 | 설명 |
|------|------|
| Working Directory | 실제 작업하는 공간 |
| Staging Area | 커밋할 변경 사항을 모아두는 공간 |
| Repository (.git) | 모든 버전 기록 저장 |
| Stash | 잠시 숨겨놓는 임시 공간 |

📌 상태 이동 흐름  
`add → commit → push`

---

## 🌿 브랜치 개념
- 기존 코드를 복사해 **독립적으로 개발**
- 필요 시 **메인 브랜치와 merge 가능**
- 새로운 기능 개발, 실험용 작업에 안전한 환경 제공  
> 마치 나무 가지처럼 뻗어나갔다가 다시 줄기로 합류하는 방식 🌳

---

## ☁ GitHub란?
- **Git 저장소를 온라인에서 관리**할 수 있는 플랫폼
- 협업, 코드 리뷰, 문서화 기능 제공
- 무료 계정은 공개 저장소 제공, 비공개는 유료
- 전 세계 개발자가 사용하는 대표 오픈소스 플랫폼

---

## ⚙ 깃 설정과 저장소 생성 정리

### 🔧 Git 최초 설정 (새 PC에서 딱 한 번)
필수 6가지 설정:

```bash
git config --global user.name "사용자이름"
git config --global user.email "이메일"
git config --global core.autocrlf true  # 줄바꿈 자동변환(Windows)
git config --global core.safecrlf false # 줄바꿈 오류 방지
git config --global core.editor "code --wait" # 기본 편집기(VSCode)
git config --global init.defaultBranch main # 기본 브랜치 이름
```

# 🔥 Git 커밋과 로그 – 정리
Git은 **Working Directory 작업 → Staging Area 대기 → Repository 저장** 구조로 구성된다.

- `git add` : 변경 내용을 스테이징  
- `git commit` : 저장소에 스냅샷 저장  
- 새 파일은 untracked 상태 → `git status`로 확인  
- 커밋 메시지는 `-m` 또는 편집기로 입력  
- 버전 이력 확인 : `git log`, `git log --oneline`, `git show`

> 이 단계에서 Git의 가장 기본적인 “버전 기록 흐름”을 이해할 수 있다.

---

# 🕰 로그 이력과 과거 여행 – 정리

- 여러 커밋 후 `git log`, `git log --graph`, `git log --reverse` 를 통해 흐름 확인  
- Git은 **HEAD 포인터**로 현재 위치 표현  
- `HEAD~`, `HEAD^`로 이전 커밋 가리킴  
- `git checkout 커밋` → 특정 시점으로 이동 가능

> Git은 그냥 저장이 아니라 **과거로 순간 이동하는 타임머신** 같은 도구!

---

# 🧪 [실습] 커밋과 로그 이력, 과거 여행

- hello.txt 생성 → 수정 → add → commit 반복해 3개의 스냅샷 생성  
- `git log`, `git show`로 차이 확인  
- `git checkout HEAD~`, `git checkout HEAD~2` → 과거 이동  
- `git checkout main` → 현재로 복귀  
- 상태가 깨끗해야 checkout 가능  
- 중간 작업은 `git stash`로 임시 저장 가능  

---

# 🔍 파일 비교(diff) – 정리

Git diff는 **어떤 줄이 추가/삭제** 되었는지 비교하는 기능

| 명령 | 비교 대상 |
|------|---------|
| `git diff` | 작업 ↔ 스테이징 |
| `git diff --staged` | 스테이징 ↔ 저장소 |
| `git diff A B` | 두 커밋 비교 |

> 버그 추적 / 코드 리뷰 / 기능 수정 필수 기능 (개발자의 CCTV 📹)

---

# 🗑 파일 삭제(rm) & 복원(restore) – 정리

| 명령 | 작동 |
|------|------|
| `rm` | 작업 디렉토리만 삭제 |
| `git rm` | 작업 + 스테이징 둘 다 삭제 |
| `git rm --cached` | 스테이징만 삭제 (파일은 남김) |

- 삭제 후 커밋하면 저장소 이력 반영  
- 복원은 `git restore` 로 진행  

> 잘못 지워도 걱정 마! Git은 휴지통 + 복원 서비스 탑재 😎

---

# 🧪 [실습] diff, rm, restore

- 각 영역에서 파일 상태 변화 확인 (`diff`, `diff --staged`, `diff HEAD`)  
- `git rm`, `git rm --cached` 실습  
- `git restore` 로 원상 복구  
- Git이 **저장 + 삭제 + 복원**을 제공하는 버전 시스템임을 이해

---

# 🏷 버전과 태그 활용 – 정리

- 소프트웨어 버전 : `major.minor.patch (SemVer)`
- Git의 **tag** 로 특정 버전 명명

| 태그 종류 | 특징 |
|----------|------|
| Annotated Tag | 주석/작성자/메시지 포함 |
| Lightweight Tag | 단순 이름만 저장 |

명령: `git tag`, `git show`, `git tag -d`

> “이 순간이야!” 하고 딱 꽂아두는 책갈피 📍

---

# 🌿 브랜치 개요와 관리 – 정리

- 브랜치 = 독립 작업 라인  
- 기본 브랜치: `main`
- 새로운 기능/테스트 시 별도 브랜치 생성

| 명령 | 설명 |
|------|------|
| `git branch` | 목록 |
| `git branch new` | 생성 |
| `git switch 브랜치` | 이동 |
| `git checkout 브랜치` | 이동(구 방식) |
| `git merge` | 병합 |

> 메인을 어지럽히지 않는 “평행세계 개발” 가능 ✨

---

# 🧪 [실습] 브랜치 개요와 관리

- 브랜치 생성 → 이동 → 개별 커밋  
- merge 실습 → 충돌 해결 과정 확인  
- 충돌은 Git이 표시 → 사람이 직접 조정  
- 브랜치는 협업의 질을 바꾸는 핵심 개념

네, 요청하신 내용을 **마크다운 형식**으로 정리해 드리겠습니다. 학습 자료로 활용하기 좋게 제목, 목록, 코드 강조 등을 사용하여 명확하게 구분했습니다.

---

## 💻 원격 저장소 복제 (Clone)

**GitHub**와 같은 **원격 저장소**($\text{Remote Repository}$) 전체를 내 컴퓨터(**지역 저장소**, $\text{Local Repository}$)로 복사해 오는 과정입니다.

*   **개념:** 인터넷에 저장된 버전 관리 공간을 내 컴퓨터로 통째로 가져오는 행위.
*   **실행:**
    *   `git clone 저장소주소`
    *   `git clone URL 폴더명` (원하는 이름으로 폴더를 생성하며 복제)
*   **결과:** 복제 시 **원격 저장소의 별칭($\text{origin}$)**이 자동으로 설정됩니다.
    *   `git remote -v` 명령어로 설정된 원격 저장소 주소를 확인할 수 있습니다.
*   **활용:**
    *   VS Code의 'Clone Git Repository' 기능을 사용하여 쉽게 복제 가능합니다.
    *   유명 **OSS (Open Source Software)** 프로젝트(예: TensorFlow, VSCode)도 이 방식으로 코드를 가져와 시작할 수 있습니다.

---

## 🔄 지역과 원격 저장소 연동 (Push & Pull)

지역 저장소에서 작업한 내용을 원격 저장소로 **올리거나**($\text{Push}$), 원격 저장소의 변경 사항을 **가져오는**($\text{Pull}$) 핵심적인 연동 과정입니다.

### 🔑 핵심 개념

*   **Push:** 내 컴퓨터에서 **Commit**된 변경 사항을 GitHub와 같은 원격 저장소로 업로드합니다.
    *   **명령어:** `git push origin main`
*   **Pull:** GitHub에 있는 **최신 변경 내용**을 내 컴퓨터로 가져와 지역 저장소에 병합($\text{Merge}$)합니다.
    *   **명령어:** `git pull origin main`
*   **Origin:** 원격 저장소의 **기본 별칭**($\text{Alias}$)을 의미합니다.

### 🚨 중요 포인트

*   **순서:** $\text{Push}$를 하기 전에는 반드시 변경된 파일을 `add` $\to$ `commit` 해야 합니다.
*   **충돌 관리:** 여러 사용자가 함께 작업할 경우, $\text{Push}$하기 전에 **반드시 $\text{Pull}$을 먼저** 하여 최신 상태를 확인해야 $\text{Conflict}$ (충돌)을 방지할 수 있습니다.
    *   **필수 흐름:** $\text{Pull} \to \text{작업} \to \text{Commit} \to \text{Push}$

---

## 🌿 지역과 원격 저장소 브랜치 연동

원격 저장소와 지역 저장소 간에 브랜치($\text{Branch}$)를 생성하고 연결하는 실습 내용입니다.

*   **기본 브랜치:** `Clone`된 저장소는 기본적으로 `main` 브랜치를 추적합니다.
*   **새 브랜치 생성 및 연결:**
    1.  지역 저장소에서 새 브랜치 생성 및 작업.
    2.  이 브랜치를 원격 저장소에도 동일하게 생성(`Push`)합니다.
    *   **최초 $\text{Push}$:** `git push -u origin 새브랜치`
        *   `-u` 옵션은 지역 브랜치와 원격 브랜치를 연결($\text{upstream}$ 설정)합니다.
    3.  이후부터는 해당 브랜치에서 단순히 `git push`만 입력해도 자동으로 연결된 원격 브랜치로 $\text{Push}$됩니다.
*   **도구 활용:** VS Code와 같은 도구에서도 브랜치 생성, 전환, $\text{Push}/\text{Pull}$ 관리가 편리하게 가능합니다.

---

## 💡 오픈소스 소프트웨어 개요 (OSS: Open Source Software)

소스코드를 누구나 **자유롭게** 열람, 수정, 재배포할 수 있도록 공개한 소프트웨어입니다.

*   **기본 정신:** **'공유와 협업'**
    *   **OSI (Open Source Initiative):** 공개 소스 정의($\text{OSD}$)를 관리하고 인증합니다.
*   **철학적 배경:** **자유 소프트웨어 철학($\text{GNU}$)**에서 출발했습니다.
    *   **무료($\text{Free of cost}$)**가 아닌 **자유($\text{Freedom}$)**롭게 사용할 수 있어야 한다는 개념에 중점을 둡니다.
    *   **카피레프트($\text{Copyleft}$):** 수정한 소스 코드를 다시 공개해야 하는 의무를 포함하는 개념입니다.
*   **협업 플랫폼:** GitHub, GitLab, Bitbucket 등은 OSS 개발을 지원하는 대표적인 협업 서버입니다.
*   **장점:** 커뮤니티 기반 협업을 통한 빠른 수정 및 개선.
*   **단점:** 품질 관리, 보안, 유지보수 부담 등이 존재할 수 있음.
*   **활용 사례:**
    *   **웹 개발:** $\text{LAMP}$ 스택 ($\text{Linux, Apache, MySQL, PHP}$).
    *   **인기 도구:** Python, TensorFlow, PyTorch 등.

### 📜 오픈소스 라이선스 종류

다양한 형태가 있으며, 소스코드 공개 의무와 저작권 고지 의무의 강도가 다릅니다.

| 라이선스 | 특징 | 의무 강도 |
| :--- | :--- | :--- |
| **GPL, AGPL** | 강한 카피레프트 (수정 코드 공개 의무) | 높음 |
| **LGPL** | 부분적 카피레프트 | 중간 |
| **Apache, MIT, BSD** | 조건이 가장 느슨함 (자유로운 사용, 저작권 고지 필수) | 낮음 |

---

## 💾 임시저장 (Stash)

작업 중이던 변경 사항을 **임시로 저장**해두고 작업 디렉토리를 **깨끗한 상태**로 되돌릴 수 있는 $\text{Git}$ 기능입니다. 갑자기 다른 브랜치로 전환해야 할 때 유용합니다.

### 📌 기능 요약

*   **저장:** `git stash`
    *   현재 변경사항을 스택($\text{Stack}$)처럼 저장하고 작업 디렉토리를 초기화합니다.
*   **목록 확인:** `git stash list`
    *   저장된 $\text{stash}$ 목록을 확인합니다.
*   **적용:** `git stash apply`
    *   $\text{stash}$ 내용을 다시 작업 디렉토리에 적용합니다 (저장 목록에서는 $\text{삭제 X}$).
*   **적용 및 제거:** `git stash pop`
    *   $\text{stash}$ 내용을 적용함과 동시에 $\text{stash}$ 목록에서 제거합니다.
*   **삭제:** `git stash drop`
    *   특정 $\text{stash}$를 목록에서 삭제합니다.
